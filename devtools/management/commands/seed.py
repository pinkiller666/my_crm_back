from django.core.management.base import BaseCommand
from django.utils import timezone
from random import choice, randint
from datetime import timedelta
from calendar import monthrange

from django.contrib.auth import get_user_model

from identity.models import User, Manager, Artist, Commissioner, CommissionerContact, ArtistContact
from artworks.models import Commission, PriceEntry, Artwork
from accounting.models import Payment
from common.choices import SocialMediaChoices
from common.choices import currency_choices

from schedule.models import SchedulePattern, PatternMode, MonthSchedule  # имя аппки поправь если другое
from decimal import Decimal


class Command(BaseCommand):
    help = "Create demo data for local development (artists, commissioners, commissions, payments)."

    def add_arguments(self, parser):
        parser.add_argument("--wipe", action="store_true", help="Delete existing demo data before seeding.")
        parser.add_argument("--artists", type=int, default=3, help="How many artists to create.")
        parser.add_argument("--per-artist", type=int, default=4, help="How many commissions per artist.")

    def handle(self, *args, **opts):
        wipe = opts["wipe"]
        n_artists = opts["artists"]
        per_artist = opts["per_artist"]

        User = get_user_model()

        if wipe:
            self.stdout.write(self.style.WARNING("Wiping demo data…"))
            Payment.objects.all().delete()
            Artwork.objects.all().delete()
            Commission.objects.all().delete()
            PriceEntry.objects.all().delete()
            CommissionerContact.objects.all().delete()
            ArtistContact.objects.all().delete()
            Commissioner.objects.all().delete()
            Artist.objects.all().delete()
            Manager.objects.all().delete()
            # пользователей не трогаем целиком — только наших демо
            User.objects.filter(username__startswith="demo_").delete()

        # 1) Менеджер и суперюзер (если нужно)
        manager_user, _ = User.objects.get_or_create(
            username="nikita",
            defaults=dict(
                email="manager@example.com",
                role="manager",
                is_staff=True,
                is_superuser=False,
            ),
        )
        manager_user.set_password("nikita")
        manager_user.save()

        manager, _ = Manager.objects.get_or_create(user=manager_user)

        # 2) Несколько комиссионеров (клиентов)
        commissioners = []
        base_commissioners = [
            ("Najatt Inc", "najatt@example.com"),
            ("DJComps", "dj@example.com"),
            ("Han Buyer", "han@example.com"),
            ("Jessica Client", "jess@example.com"),
        ]
        for name, email in base_commissioners:
            comm, _ = Commissioner.objects.get_or_create(
                name=name,
                defaults=dict(paypal_email=email, notes="Demo commissioner"),
            )
            commissioners.append(comm)
            # контакты комиссионера
            self._ensure_commissioner_contacts(comm)

        # 3) Художники + прайсы + контакты
        artists = []
        for i in range(1, n_artists + 1):
            u, _ = User.objects.get_or_create(
                username=f"demo_artist_{i}",
                defaults=dict(
                    email=f"artist{i}@example.com",
                    role="artist",
                    is_staff=False,
                    is_superuser=False,
                    first_name=f"Artist{i}",
                    last_name="Demo",
                ),
            )
            u.set_password("demo1234")
            u.save()

            artist, _ = Artist.objects.get_or_create(user=u, defaults=dict(manager=manager))
            artists.append(artist)

            # контакты художника
            self._ensure_artist_contacts(artist)

            # прайсы для художника
            self._ensure_price_list(artist)

        # 4) Комиссии, арты, платежи
        ccy_codes = [c[0] for c in currency_choices]  # ['USD','RUB','EUR','KZT']
        today = timezone.now().date()

        for artist in artists:
            for j in range(1, per_artist + 1):
                comm = choice(commissioners)
                amount = Decimal(randint(80, 400))  # 80–400 условных
                currency = choice(ccy_codes)

                commission = Commission.objects.create(
                    name=f"Demo Commission {artist.user.username}-{j}",
                    artist=artist,
                    commissioner=comm,
                    amount=amount,
                    currency=currency,
                    accepted_at=today - timedelta(days=randint(0, 60)),
                    description="Autogenerated demo commission",
                )

                # # артовая запись (пустая картинка — просто запись для тестов фронта)
                # Artwork.objects.create(
                #     commission=commission,
                #     title=f"Artwork for {commission.name}",
                #     notes="Demo artwork (no file)",
                # )

                # платеж(и)
                pay_amount = amount if randint(0, 1) else (amount // 2)
                Payment.objects.create(
                    order=commission,  # ← поле называется order, не commission
                    amount=pay_amount,
                    currency=currency,
                    pay_system="paypal",  # в твоих choices: 'paypal' или 'bank_transfer'
                    # paid_at — такого поля нет. created_at выставится автоматически
                )

        self.stdout.write(self.style.SUCCESS("Demo data created successfully."))

        self._ensure_schedule_patterns()

    # ---------- helpers ----------

    def _ensure_commissioner_contacts(self, commissioner):
        # добавим 1–2 контакта
        CommissionerContact.objects.get_or_create(
            commissioner=commissioner,
            social_media=SocialMediaChoices.EMAIL,
            handle=commissioner.paypal_email or f"{commissioner.name.lower()}@example.com",
            defaults=dict(url=""),
        )
        # второй — опционально
        CommissionerContact.objects.get_or_create(
            commissioner=commissioner,
            social_media=SocialMediaChoices.TELEGRAM,
            handle=f"@{commissioner.name.lower().replace(' ', '')}",
            defaults=dict(url=""),
        )

    def _ensure_artist_contacts(self, artist):
        ArtistContact.objects.get_or_create(
            artist=artist,
            social_media=SocialMediaChoices.TWITTER,
            handle=f"@{artist.user.username}",
            defaults=dict(url=f"https://x.com/{artist.user.username}", notes=""),
        )
        ArtistContact.objects.get_or_create(
            artist=artist,
            social_media=SocialMediaChoices.BLUESKY,
            handle=f"{artist.user.username}.bsky.social",
            defaults=dict(url=f"https://bsky.app/profile/{artist.user.username}.bsky.social", notes=""),
        )

    def _ensure_price_list(self, artist):
        titles = ["Fullbody", "Halfbody", "Bust", "Chibi"]
        for title in titles:
            PriceEntry.objects.get_or_create(artist=artist, title=title)

    def _ensure_schedule_patterns(self):
        """
        Создаёт (idempotent) базовые шаблоны расписания.
        """
        created = []

        # --- ALTERNATING ---
        presets_alt = [
            # name, days_off_at_start, pattern_after_start, last_day_always_working, working_day_duration
            ("4 выходных, потом 2 через 2 — последний день рабочий",
             4, [2, 2], True, Decimal("4.00")),
            ("7 выходных, потом 2 через 2 — последний день рабочий",
             7, [2, 2], True, Decimal("4.00")),
            ("0 выходных, 2 через 2 — последний день как придётся",
             0, [2, 2], False, Decimal("4.00")),
        ]

        for name, d_off, seq, last_work, hours in presets_alt:
            obj, was_created = SchedulePattern.objects.get_or_create(
                name=name,
                defaults=dict(
                    description="Автосозданный базовый шаблон (ALTERNATING).",
                    mode=PatternMode.ALTERNATING,
                    days_off_at_start=d_off,
                    pattern_after_start=seq,
                    weekday_map=None,
                    last_day_always_working=last_work,
                    working_day_duration=hours,
                ),
            )
            # если существовал, но структура отличается — мягко обновим
            changed = False
            if obj.mode != PatternMode.ALTERNATING:
                obj.mode = PatternMode.ALTERNATING;
                changed = True
            if obj.days_off_at_start != d_off:
                obj.days_off_at_start = d_off;
                changed = True
            if (obj.pattern_after_start or []) != seq:
                obj.pattern_after_start = seq;
                changed = True
            if obj.weekday_map:
                obj.weekday_map = None;
                changed = True
            if obj.last_day_always_working != last_work:
                obj.last_day_always_working = last_work;
                changed = True
            if obj.working_day_duration != hours:
                obj.working_day_duration = hours;
                changed = True
            if changed: obj.full_clean(); obj.save()

            created.append((obj.name, was_created))

        # --- WEEKDAY ---
        weekday_sets = [
            # name, weekday_map
            ("Пн–Пт рабочие, Сб–Вс выходные",
             {"mon": "work", "tue": "work", "wed": "work", "thu": "work", "fri": "work", "sat": "off", "sun": "off"}),
            ("Пн,Вт — работа; Ср — выходной; Чт,Пт — работа; Сб,Вс — выходные",
             {"mon": "work", "tue": "work", "wed": "off", "thu": "work", "fri": "work", "sat": "off", "sun": "off"}),
        ]

        for name, wm in weekday_sets:
            obj, was_created = SchedulePattern.objects.get_or_create(
                name=name,
                defaults=dict(
                    description="Автосозданный базовый шаблон (WEEKDAY).",
                    mode=PatternMode.WEEKDAY,
                    days_off_at_start=0,
                    pattern_after_start=[],
                    weekday_map=wm,
                    last_day_always_working=False,
                    working_day_duration=Decimal("4.00"),
                ),
            )
            # мягкое обновление при расхождениях
            changed = False
            if obj.mode != PatternMode.WEEKDAY:
                obj.mode = PatternMode.WEEKDAY;
                changed = True
            if obj.days_off_at_start != 0:
                obj.days_off_at_start = 0;
                changed = True
            if obj.pattern_after_start:
                obj.pattern_after_start = [];
                changed = True
            if (obj.weekday_map or {}) != wm:
                obj.weekday_map = wm;
                changed = True
            if obj.last_day_always_working:
                obj.last_day_always_working = False;
                changed = True
            if obj.working_day_duration != Decimal("4.00"):
                obj.working_day_duration = Decimal("4.00");
                changed = True
            if changed: obj.full_clean(); obj.save()

            created.append((obj.name, was_created))

        # лог
        for name, was_created in created:
            tag = "создан" if was_created else "обновлён"
            self.stdout.write(self.style.SUCCESS(f"SchedulePattern «{name}» {tag}."))

    def _assign_random_month_schedules(self, artists):
        """
        Для каждого художника создаём MonthSchedule на 1–2 месяца
        (текущий + иногда предыдущий) с рандомным SchedulePattern.
        Идемпотентно: get_or_create.
        """
        today = timezone.localdate()
        year = today.year
        month = today.month

        patterns = list(SchedulePattern.objects.all())
        if not patterns:
            self.stdout.write(self.style.WARNING("Нет SchedulePattern — пропускаю назначение MonthSchedule."))
            return

        for artist in artists:
            user = artist.user

            # всегда — текущий месяц
            pat = choice(patterns)
            ms, created = MonthSchedule.objects.get_or_create(
                user=user,
                year=year,
                month=month,
                defaults={"pattern": pat},
            )
            if not created and ms.pattern_id != pat.id:
                # мягко не трогаем существующее: если хочешь обновлять — раскомментируй 2 строки ниже
                # ms.pattern = pat
                # ms.save(update_fields=["pattern"])
                pass

            # иногда — предыдущий месяц
            if randint(0, 1):
                prev_year = year
                prev_month = month - 1
                if prev_month == 0:
                    prev_month = 12
                    prev_year -= 1

                pat_prev = choice(patterns)
                MonthSchedule.objects.get_or_create(
                    user=user,
                    year=prev_year,
                    month=prev_month,
                    defaults={"pattern": pat_prev},
                )

            if randint(0, 1):
                next_year = year
                next_month = month + 1
                if next_month == 13:
                    next_month = 1
                    next_year = year + 1

                pat_next = choice(patterns)
                MonthSchedule.objects.get_or_create(
                    user=user,
                    year=next_year,
                    month=next_month,
                    defaults={"pattern": pat_next},
                )
